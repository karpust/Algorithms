графы
============================================================================
это абстрактный способ представления типов отношений
множество вершин соединенных множеством ребер
Графы бывают:
ориентированный (направленные связи: 1 ссылается на 2, а 2 на 1-нет)
                отношения действуют в 1 сторону, или
неориентированный (1 явл соседом 2, а 2 соседом 1)

путь - последовательное соединение разных вершин ребрами
маршрут - ребра соединяют вершины не последовательно
цикл - группа вершин связанных в замкнутую цепь
связный граф - между любой парой вершин есть путь
дерево - связный граф без цикла(между любыми 2мя вершинами только 1 путь)

хранение графа - списки смежности
-------------------------------------------
https://foxford.ru/wiki/informatika/hranenie-grafa-spiski-smezhnyh-vershin
граф можно представить списками смежности -
т е для каждой вершины хранится список смежных с ней вершин
например есть направленный граф в котором:
W[1] = [2] - вершина 1 ссылается на вершину 2
W[2] = [4, 5] - вершина 2 ссылается на вершины 4, 5 итд
W[3] = [1, 4]
W[4] = [1, 3]
W[5] = [] - вершина 5 ни на что не ссылается
получим: [[2], [4, 5], [1, 4], [1, 3], []]



поиск в глубину - Depth-first search (DFS)
------------------------------------------------
Обход дерева вглубину:
1) Прямой(pre-order traversal):
    посетить корень
    обойти левое поддерево
    обойти правое поддерево

2) Симметричный или поперечный (in-order traversal)
    Обойти левое поддерево
    Посетить корень
    Обойти правое поддерево

3) Обратный (post-order traversal)
    Обойти левое поддерево
    Обойти правое поддерево
    Посетить корень

идти вглубь графа насколько возможно
алгоритм обхода
применяется для поиска пути от одной вершины до других
    Помещаем любую из вершин графа на стек.
    Берём элемент со стека и добавляем его в список посещённых.
    Создаём список соседей этой вершины. Добавляем в стек те,
    что не находятся в списке посещённых.
    Повторяем 2 и 3 пункты, пока стек не опустеет.

Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра.
Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой
нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит
в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную
вершину. Если после завершения алгоритма не все вершины были рассмотрены, то необходимо запустить
алгоритм от одной из нерассмотренных вершин.



поиск в ширину - Breadth-First Search
-------------------------------------------
алгоритм для поиска кратчайшего пути
Поиск в ширину работает путём последовательного просмотра отдельных уровней графа
    Pick any node, visit the adjacent unvisited vertex, mark it as visited,
    display it, and insert it in a queue.
    If there are no remaining adjacent vertices left,
    remove the first vertex from the queue.
    Repeat step 1 and step 2 until the queue is empty or the desired node is found.

Дерево
==============
это связный граф, не имеющий циклов


Двоичное дерево
=========================================================================================================
структура данных, в которой каждый узел имеет не более двух потомков
полезны подвиды двоичного дерева: двоичное дерево поиска и двоичная куча(пирамида)
отличие ддп от дкуч:
у ддп все левые потомки меньше а правые больше родителя
у дкучи все потомки меньше(больше) родителя

имеют:
узел(ключ) - вершины имеют не более 2 потомков
корень - узел кот не имеет входящих ветвей, только выходящие
ветвь - соединяет два узла, все узлы кроме корня имеют одну входящую ветвь
лист - узел кот не имеет детей
путь - последовательность узлов соединенных ветвями
глубина узла(уровень) = кол-во ветвей кот ведут к этому узлу от корня
высота узла = самый длинный путь от узла до внешнего узла
высота дерева = самый длинный путь от корня до внешнего узла


Двоичное дерево поиска(ДДП) - binary search tree(BST)
--------------------------------------------------------------
это двоичное дерево кот выполняет условия:
1) все узлы левого поддерева меньше родительского (или корня)
2) все узлы правого поддерева больше родительского (или корня)
3) все его поддеревья являются ДДП

явл эффективным способом поиска;
поиск элемента, поиск минимального (максимального) элемента, вставка, удаление.
сложность:
в среднем - логарифмическая
в худшем - линейная


куча
--------------
структура данных типа дерево.
(эта структура данных раньше использовалась для динамического распределения
памяти поэтому так называют еще выделенную память. это разные понятия)

свойство кучи:
корневой узел кучи = max (для max-heap)
корневой узел кучи = min (для min-heap)


двоичная куча или пирамида
-----------------------------------
это двоичное дерево кот выполняет условия:
1) значение у вершины не больше чем у её потомков(для min-куч)
2) на i-ом слое 2^i вершин, кроме последнего. Слои нумеруются с нуля.
   (т е не можем начинать новый слой если есть незаполненый)
3) последний слой заполнен слева(мин) направо (для min-куч?)

двоичную кучу хранят в виде массива a[0..n−1], у кот a[0] — корень,
а потомками элемента a[i] являются a[2i+1] и a[2i+2]

